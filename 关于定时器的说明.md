### 基于最小堆的定时器
#### 功能：
断开超时的连接，避免资源被长时间的占用

#### 原理：
利用最小堆的性质：堆顶元素是最小的，来淘汰最先到达超时时间的连接  
堆的操作主要是上滤和下滤操作，用来重新维持最小堆的性质:

* 上滤：将当前结点和父结点比较，如果当前值较小则与父结点进行交换，保证小的往上走，用于结点的插入  
* 下滤：将当前结点和左右孩子结点比较，如果当前结点的孩子比该结点小则将较小的孩子结点和当前结点交换，保证小的往上走，用于结点的删除  
 

#### 小根堆定时器分析:
定时器结点有三个属性:  

* 该定时器生效的绝对时间
* 定时器的回调函数
* 客户端数据(该连接的文件描述符)

许多个的定时器结点构成了一个定时器堆，该堆遵从最小堆的性质，这样最先淘汰的就是最小的时间  

* 堆的结点采用数组存储(根结点：N，左孩子：2N+1,右孩子：2N+2)，不仅节省空间，而且更容易进行插入和删除  

* 堆数组支持自动扩容,自动扩容一倍，另外申请一个原数组一倍大小的空间，逐个迁移过去，最后销毁原数组，一开始就把数组开得足够大，并且过期结点会被删除，所以扩容操作进行的次数很少，不会影响定时器的性能

* 在连接还没有超时的时候，如果连接就关闭了，那么需要同时删除堆中该连接的定时器，这里采用延迟销毁的方式：将该定时器的回调函数置NULL，可以节省删除定时器的开销，在该定时器超时之后才会在心跳函数中被真正删除

* 心跳函数能删除所有过期结点：堆顶元素过期则删除堆顶元素然后将堆底元素放到堆顶，然后进行下滤重新恢复小根堆的性质

* 连接刚到的时候不会将该连接的定时器加入堆中，只会对该连接的定时器进行初始化，当改连接被处理过一次之后才会将连接的定时器加入到堆中，这样可以使得堆中的元素尽可能的少，因为连接被处理过一次之后大部分都完成了所有任务然后关闭了连接，这种被处理得很快的连接没有必要被执行定时操作

#### 定时器时间复杂度分析：  
评判定时器性能的四个要素：  

* StartTimer：注册一个定时器结点到总定时器中  

* StopTimer：找到超时的定时器  

* PerTickBookkeeping：在一个tick内，定时器系统需要执行的动作，它的主要行为就是检测定时器系统中是否有定时器到期

* ExpiryProcessing：在定时器到期之后，执行定时器的回调函数  

对我们基于小根堆的定时器而言：  

* StartTimer：就是往堆中添加定时器结点：O(lg n)

* StopTimer:就是找堆顶元素：O(1)  

* PerTickBookkeeping:就是检测堆中是否有超时的，直接检测堆顶即可：O(1)

* ExpiryProcessing:执行定时器的回调函数:O(1)

综上所述，我们可以得出一个结论：基于小根堆的定时器其性能还是不错的！  
ps：后面会采用时间轮的方式实现定时器，这样插入定时器结点为O(1),性能进一步提升