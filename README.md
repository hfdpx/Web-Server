# Web-Server

### 版本1：单进程+BIO 的web server!  
  * 使用包裹函数处理错误  
  
  当没有连接到来的时候,该进程会阻塞在Accept函数上,  
  当有多个连接到来的时候，只能处理一个连接，其他连接进入阻塞队列等待，  
  
  当然,这里的connfd也是阻塞版本的！也就是说,在对connfd执行write,read等函数的时候也会阻塞.  
  比如一个连接要先reda资源然后write资源，如果要reda的时候服务器没有准备好，那么系统会阻塞处理该连接的进程，等待要read的资源准备好  
  
  这样一来,这个版本的server效率会非常低下！
  
  
  
### 版本2：多进程+BIO 的web server!

  * 比单进程+BIO版本的server效率有所提高  

  当没有连接到来的时候,该进程会阻塞在Accept函数上,  
  当有多个连接到来的时候，为每一个连接fork一个进程  

  当然,这里的connfd也是阻塞版本的！也就是说,在对connfd执行write,read等函数的时候也会阻塞.  
  比如一个连接要先reda资源然后write资源，如果要reda的时候服务器没有准备好，那么系统会阻塞处理该连接的进程，等待要read的资源准备好  

  因为是BIO的，每个进程可能因为连接没有请求到相应的资源而阻塞

  这样一来，多进程+BIO版本的server效率仍然不是很高！

###### 解决的bug:  
  * 解决了僵死进程的问题

### 版本3:多线程+BIO 的web server!
  
  * 和多进程+BIO版本的web server各有千秋
  * 其效率取决于server的业务和物理机器的硬件资源  
###### 解决的问题:  
  *  连接频繁的情况下，还没有来得及传递给新线程的套接字描述符被新到来的连接覆盖导致某些客户的连接无法响应的问题
  *  解决了 解决上述问题采取的方案 导致的线程运行中内存泄漏的问题
  *  实现了资源的自动回收
###### 总结:
跟多进程+BIO的版本相差不大,都是为每个新的连接建立一个进程或者线程,下一版本可以考虑采用线程池降低线程创建和销毁的开销


#### ps:关于多进程和多线程的对比
###### “鱼和熊掌不可兼得”  
  * 数据的共享与同步：
    * 多进程数据共享复杂，需要用IPC，数据是分开的，同步也简单
    * 多线程共享进程数据，所以数据共享简单，但同步复杂
  * 内存和CPU占比：
    * 多进程占用内存多，切换复杂，CPU利用率低
    * 多线程占用内存少，切换简单，CPU利用率高  
  * 创建和销毁：
    * 进程的创建，销毁和切换复杂，速度慢
    * 线程的创建，销毁和切换简单，速度快
  * 可靠性：  
    * 进程间不会互相影响，一个进程的崩溃不会影响其他进程
    * 一个线程挂掉将导致整个进程挂掉
  * 分布式：
    * 适用于多核，多机分布式，如果一台机器不够，扩展到多台机器简单
    * 只使用于多核分布式
  * 编程和调试：  
    * 多进程编程和调试简单
    * 多线程编程和调试复杂
###### 写Web Server个人倾向于使用多线程  

### 版本4:线程池+BIO 的web server  
合理的利用线程池能带来三个好处:    

* 1.降低资源消耗,不用频繁的创建和消耗线程    
* 2.提高响应速度，任务可以不需要等待线程建立就可以立即执行，这点对web server来说至关重要！   
* 3.提高线程的可管理性，毕竟来一个连接创建一个线程这种做法导致我们无法进行统一的管理和调配  

###### 采取的措施:  
* 1.参照陈硕大神的muduo库，实现了一个条件变量condition类，用来实现线程之间的协作  
* 2.同样也是参照muduo库，实现了一个互斥锁Mutex类，利用RAll机制，实现了自动加锁和解锁  
* 3.线程池中任务队列采用任务数组和头尾指针滚动的形式实现，线程全部预先创建
* 4.其他做法跟多线程+BIO版本的web server类似  
###### 解决的bug：
* 虚假唤醒问题  
###### 存在的问题:
* 任务太多可能导致任务队列中没有完成的任务被覆盖  
* 线程全部预先创建没有必要  
###### 总结:  
线程池的实现简陋了点，下一版本目标是实现一个完整的线程池，解决上面存在的问题

### 版本5:完整的线程池+BIO 的web server  
* 任务队列采用链表+头尾双指针实现
###### 线程池原理：
* 线程池有一个属性为线程池允许的最大线程数
* 任务到来了则将任务插入到任务队列尾部
* 在任务队列不空的情况下，线程池中存在空闲线程则将队首任务交给该空闲线程，不存在空闲线程的话，如果当前线程数量小于线程池允许的最大线程数则创建新线程执行队首任务，否则将等待其他线程空闲
##### 存在的问题：
* 因为是BIO，所以效率仍然达不到高性能web server的要求！
##### 总结：  
* 解决了版本4存在的问题，整个线程池非常完整，封装得也还可以！下一版本的目标是实现非阻塞IO  
### 版本6:单线程 + IO多路复用(epoll LT) + Reactor模式 的web server  
* 采用epoll，使用LT模式实现IO多路复用

* 将http处理代码封装成了Httphandle类，配备读写缓冲区，连接描述符，发送的文件信息，以及读写相关指针等信息  

* 采用Cache机制，将用户群体经常访问的一些页面放入Cache中，提高响应速度  

* Cache机制中采用了智能指针，方便缓存资源的释放  

* 采用OS的LRU最近最久未使用页面置换算法实现Cache中文件的置换，以便更少的产生"缺页"现象  

* 采用状态机机制实现页面请求的处理,便于处理请求  

##### 不足:  
  * LT模式可以改为效率更高的ET模式
  * 可以采用多线程进行处理

### 版本7:单线程 + IO多路复用(epoll ET) +Reactor模式 的web server  
* 采用比LT模式效率更高的ET模式，目的是减少事件被触发的次数  
* 其他同上版本  
### 版本8:线程池+ IO多路复用(epoll ET) + Reactor模式 的web server  
* Reactor模式

* 实现了一个线程池和生产者消费者模型  

* 实现了一个条件变量condition类，用来实现线程之间的协作  

* 实现了一个互斥锁Mutex类，利用RAll机制，实现了自动加锁和解锁  

* 任务队列的锁采用分段锁机制，头部一个锁，尾部一个锁，插入任务和获得任务可以同时进行，统计任务数量则需要获得两把锁  

* 采用两个条件变量代表任务队列可读或可写，降低了锁的操作次数

* 封装了一个日志函数

* 使用了右值引用和move语义，提高了效率

* 使用了cpp的新特性，使用boost::funciton和boost::bind代替template，增加了程序可读性
 
* 解决了Cache中shared_ptr多线程不安全问题  

* 通过EPOLLONESHOT避免了一个连接的数据被多个线程读取的情况  
### 版本9:最后的版本  
* 参考moduo库，实现了一个高效带缓冲的的Buffer类，支持自适应扩容，内存连续，利用了临时的栈上空间暂存数据，带缓冲，不用自己去read()或write某个socket，只用操作TcpConnection的input buffer和output buffer.  
![](https://img-my.csdn.net/uploads/201104/17/0_1303014373Vfgb.gif)  
![](https://img-my.csdn.net/uploads/201104/17/0_1303014373FZQM.gif)


* 为了更好的处理连接，将处理连接的动作拆分了出来组成了一个HttpRequest类

* 解决了一个连接数据可能被多个线程读的情况

* 完善了状态机机制，服务器现在能有效处理客户端发送不规则数据造成的各种情况

![](https://img-blog.csdn.net/20161104143716693)
![](https://img-blog.csdn.net/20161104143648365)












